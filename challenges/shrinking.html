<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Word Search — Shrinking Mode (Levels)</title>
  <style>
    :root {
      /* defaults (light theme) */
      --bg-1: #ffffff;
      --bg-2: #f8fafc;
      --muted: #64748b;
      --ink: #1e293b;
      --good: #16a34a;
      --warn: #f59e0b;
      --bad: #dc2626;
      --cell-size: 40px;
      --pu-color: rgba(0, 0, 0, 0.03);
      --small-btn-bg: rgba(0, 0, 0, 0.04);
    }

    /* Dark theme overrides */
    [data-theme="dark"] {
      --bg-1: #0b1020;
      --bg-2: #0f1726;
      --muted: #9aa3d6;
      --ink: #e9eeff;
      --good: #35d67a;
      --warn: #ffc857;
      --bad: #ff6b6b;
      --pu-color: rgba(255, 255, 255, 0.03);
      --small-btn-bg: rgba(255, 255, 255, 0.03);
    }

    * {
      box-sizing: border-box
    }

/* Light theme button colors */
[data-theme="light"] #themeToggle {
  --toggle-bg: #e2e8f0;
  --toggle-hover: #cbd5e1;
  --toggle-text: #1e293b;
}

/* Dark theme button colors */
[data-theme="dark"] #themeToggle {
  --toggle-bg: #1e293b;
  --toggle-hover: #334155;
  --toggle-text: #f1f5f9;
}


    html,
    body {
      height: 100vh;
            background:
        radial-gradient(1200px 600px at 10% 10%, rgba(108, 140, 255, 0.06), transparent),
        radial-gradient(1000px 500px at 90% 90%, rgba(126, 240, 214, 0.03), transparent),
        linear-gradient(180deg, var(--bg-1), var(--bg-2));
      color: var(--ink);
      overflow: hidden;
    }

    body {
      margin: 0;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      padding: 12px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 14px
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center
    }

    .brand {
      display: flex;
      gap: 12px;
      align-items: center
    }

    .logo {
      width: 44px;
      height: 44px;
      border-radius: 10px;
      background: linear-gradient(135deg, #4f6bff, #7ef0d6);
      display: grid;
      place-items: center;
      font-weight: 800;
      color: #03102a
    }

    .title {
      font-weight: 800
    }

    .controls {
          display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    width: 100%;
    }

    .score-coins {
      display: flex;
      gap: 30px;
      align-items: center;
      font-weight: 800
    }

    .coins {
      padding: 6px 10px;
      border-radius: 8px;
      font-weight: 900
    }

    button {
      border: 0;
      background: #4162a8;
      color: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: 700;
      cursor: pointer
    }

    button.secondary {
      background: transparent;
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, 0.04)
    }

    main {
      display: flex;
      flex-direction: column;
      gap: 18px;
      align-items: flex-start;
      height: 100vh;
    }

    .board {
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.015));
      padding: 5px;
      border-radius: 12px;
      width:100%;
      height: fit-content;
    }

    .side {
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.015));
      padding: 12px;
      border-radius: 12px;
      margin: 0 auto;
    }

    .grid {
      --size: 15;
      display: grid;
       grid-template-columns: repeat(var(--size), var(--cell-size));
      gap: 3px;
      justify-content: center;
      width: fit-content;
      overflow: hidden;
      margin: 0 auto;
      padding: 5px;
    }

    .cell {
      width: var(--cell-size);
      height: var(--cell-size);
      display: grid;
      place-items: center;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 8px;
      font-weight: 800;
      text-transform: uppercase;
      color: var(--ink);
      transition: transform .12s ease, opacity .25s ease, background .25s ease;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-user-drag: none;
    }

    /* mobile fix: prevent browser gesture handling on grid & cells so touch drags go to JS */
    .grid,
    .cell {
      touch-action: none;
    }

    .cell.hl {
      outline: 2px solid rgba(255, 200, 90, 0.12)
    }

    .cell.good {
      outline: 2px solid var(--good)
    }

    .cell.warn {
      background: linear-gradient(135deg, rgba(255, 200, 90, 0.12), rgba(255, 160, 60, 0.06));
      animation: warnPulse 1200ms infinite
    }

    @keyframes warnPulse {
      0% {
        transform: scale(1)
      }

      50% {
        transform: scale(1.03)
      }

      100% {
        transform: scale(1)
      }
    }

    .cell.shrunk {
      opacity: 0.08;
      color: transparent;
      pointer-events: none;
      transform: scale(.98);
      background: transparent
    }

    .cell.lock {
      background: linear-gradient(135deg, rgba(55, 214, 122, 0.12), rgba(32, 80, 255, 0.06));
      color: #eafef3
    }

    .words {
      display: flex;
      gap: 8px;
      grid-template-columns: repeat(2, 1fr)
    }

    .balanceIcon {
      width: 20px;
      margin-bottom: -5px;
      margin-right: 7px;
    }

    button {
    font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #4162a8;
    border-top: 1px solid #38538c;
    border-right: 1px solid #1f2d4d;
    border-bottom: 1px solid #151e33;
    border-left: 1px solid #1f2d4d;
    -webkit-border-radius: 4px;
    -moz-border-radius: 4px;
    border-radius: 4px;
    -webkit-box-shadow: inset 0 1px 10px 1px #5c8bee, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
    -moz-box-shadow: inset 0 1px 10px 1px #5c8bee, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
    box-shadow: inset 0 1px 10px 1px #5c8bee, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
    color: #fff;
    font: bold 20px "helvetica neue", helvetica, arial, sans-serif;
    line-height: 1;
    padding: 10px 0 12px 0;
    text-align: center;
    text-shadow: 0px -1px 1px #1e2d4d;
    width: 150px;
    -webkit-background-clip: padding-box;
    margin: 15px;
}

button:hover {
    -webkit-box-shadow: inset 0 0px 20px 1px #87adff, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
    -moz-box-shadow: inset 0 0px 20px 1px #87adff, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
    box-shadow: inset 0 0px 20px 1px #87adff, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
    cursor: pointer;
}

button:active {
    -webkit-box-shadow: inset 0 1px 10px 1px #5c8bee, 0 1px 0 #1d2c4d, 0 2px 0 #1f3053, 0 4px 3px 0 #111111;
    -moz-box-shadow: inset 0 1px 10px 1px #5c8bee, 0 1px 0 #1d2c4d, 0 2px 0 #1f3053, 0 4px 3px 0 #111111;
    box-shadow: inset 0 1px 10px 1px #5c8bee, 0 1px 0 #1d2c4d, 0 2px 0 #1f3053, 0 4px 3px 0 #111111;
    transform: translateY(4px);
}

    .word {
      padding: 6px;
      border-radius: 6px;
      background: var(--pu-color);
      font-weight: 700;
      color: var(--muted);
      text-align: center;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px
    }

    .word .label {
      flex: 1;
      text-align: left;
      padding-left: 8px
    }

    .word.found {
      color: var(--good);
      text-decoration: line-through
    }

    .word.blocked {
      color: var(--bad);
      text-decoration: line-through;
      opacity: .95
    }

    .hud {
      display: flex;
      gap: 10px;
      align-items: center
    }

    .pw

    .small {
      font-size: 13px;
      color: var(--muted)
    }

    .powerups {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 8px
    }

    .pu-row {
      display: flex;
      gap: 8px;
      align-items: center
    }

    .pu {
      padding: 8px 12px;
      border-radius: 8px;
      background: var(--pu-color);
      font-weight: 800;
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center
    }

    .pu-actions {
      display: flex;
      gap: 6px;
      align-items: center
    }

    .small-btn {
      background: var(--small-btn-bg);
      border: 1px solid rgba(255, 255, 255, 0.04);
      padding: 6px 8px;
      border-radius: 8px;
      color: var(--muted);
      cursor: pointer;
      font-weight: 700
    }

    .tiny {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 6px
    }

    .modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 900
    }

    .modal.open {
      display: flex
    }

    .backdrop {
      position: absolute;
      inset: 0;
      background: rgba(2, 6, 23, 0.6);
      backdrop-filter: blur(6px)
    }

    .card {
      position: relative;
      background: linear-gradient(180deg, rgba(101, 112, 212, 0.45), rgba(255, 255, 255, 0.01));
      padding: 22px;
      border-radius: 12px;
      width: min(520px, 92%);
      text-align: center;
      transform: translateY(10px);
      opacity: 0;
      transition: transform .36s ease, opacity .36s ease
    }

    .modal.open .card {
      transform: translateY(0);
      opacity: 1
    }

    .ad-progress {
      height: 10px;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 6px;
      overflow: hidden;
      margin-top: 12px
    }

    .ad-progress>i {
      display: block;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #ffd56b, #ffc857);
      transition: width .12s linear
    }

    @media(max-width:1000px) {
      :root {
        --cell-size: 32px
      }
    }

    @media(max-width: 900px){
      .cell {
        font-weight: 600;
        border-radius: 2px;
      }
    }

    @media(max-width:880px) {
      main {
        flex-direction: column
      }

      .side {
        width: 100%
      }

      :root {
        --cell-size: 34px
      }

      .words {
        display: flex;
        flex-wrap: wrap;
        width: 100%;
        height: fit-content;
      }

      .word {
        font-size: 14px
      }
    }

    #status {
      background: rgba(44, 66, 99, 0.185);
      font-weight: 600;
      width: 100%;
      text-align: center;
      padding: 5px;
    }

    @media(max-width:600px) {
      :root {
        --cell-size: 28px
      }

      .word {
        font-size: 13px
      }
    }

    @media(max-width:510px){
            :root {
        --cell-size: 24px
      }
    }

    @media(max-width:450px) {
      :root {
        --cell-size: 20px
      }
            .cell, .word {
        font-weight: 300;

      .word {
        font-size: 12px
      }
    }
    @media(max-width:390px){
            :root {
        --cell-size: 18px
      }
      }
      body {
        padding: 2px;
      }
    }
    @media(max-width:330px){
      :root {
        --cell-size: 17px;
      }
    }
        @media(max-width:320px){
      :root {
        --cell-size: 15px;
      }
      .grid {
        font-family: 400;
      }
    }

    #pauseBtn {
      width: 100px;
      font-size: 1rem;
    }
  </style>
</head>

<body>
  <div class="wrap" aria-live="polite">
    <header>
      <div class="controls">
        <div class="score-coins">
          <div id="score">🏆 0</div>
          <div id="coins" class="coins"><img src="../images/goldIcon.png" alt="" class="balanceIcon"> 0</div>
        </div>

        <button id="pauseBtn" class="secondary"><span id="timer">|| 0:00</span></button>

        <label class="small" style="display:none" for="levelSelect"
          style="color:var(--muted);display:flex;flex-direction:column;align-items:flex-start;font-weight:700">
          <span style="font-size:11px;color:var(--muted);font-weight:700">Level</span>
          <select id="levelSelect" title="Level"></select>
        </label>
      </div>
    </header>

    <main>
      <section class="board" aria-label="Puzzle board">
                <div style="margin-top:12px">
          <div id="status" class="small" style="margin-top:6px;color:var(--muted)">Find all words before they break!</div>
        </div>
        <div id="grid" class="grid" role="grid" aria-label="Word search grid"></div>
        <div id="message" class="small" style="margin-top:10px;color:var(--muted)"></div>
      </section>

      <aside class="side" aria-label="Sidebar">
        <div style="display:flex;justify-content:space-between;align-items:center">
        </div>
        <div id="wordList" class="words" aria-live="polite" style="margin-top:8px"></div>

        <div style="margin-top:12px">
          <div class="powerups" style="display: none;" id="powerups">
            <div class="pu-row">
              <button class="pu" id="freezeBtn">Freeze x0</button>
              <div class="pu-actions">
                <button class="small-btn tiny" id="buyFreezeBtn">Buy (8)</button>
                <button class="small-btn tiny" id="adFreezeBtn">Watch Ad</button>
              </div>
            </div>

            <div class="pu-row">
              <button class="pu" id="shieldBtn">Shield x0</button>
              <div class="pu-actions">
                <button class="small-btn tiny" id="buyShieldBtn">Buy (10)</button>
                <button class="small-btn tiny" id="adShieldBtn">Watch Ad</button>
              </div>
            </div>

            <div class="pu-row">
              <button class="pu" id="restoreBtn">Restore x0</button>
              <div class="pu-actions">
                <button class="small-btn tiny" id="buyRestoreBtn">Buy (5)</button>
                <button class="small-btn tiny" id="adRestoreBtn">Watch Ad</button>
              </div>
            </div>
          </div>
        </div>
      </aside>
    </main>
  </div>

  <!-- Start modal -->
  <div class="modal open" id="startModal" role="dialog" aria-modal="true" aria-hidden="false">
    <div class="backdrop" aria-hidden="true"></div>
    <div class="card">
      <h2>Shrinking Mode — Levels</h2>
      <p class="small">Pick an unlocked level. Each level has 10 words. Letters are warned and then removed — use
        Restore power-ups to save damaged words. Freeze pauses shrinking; Shield protects cells.</p>
      <div style="display:flex;gap:8px;justify-content:center;margin-top:10px">
        <button id="startModalBtn">▶ Start</button>
        <button id="closeStart" class="secondary">Close</button>
      </div>
              <select id="difficulty" title="Difficulty">
          <option value="easy">Easy</option>
          <option value="normal" selected>Normal</option>
          <option value="hard">Hard</option>
        </select>
    </div>
  </div>

  <!-- Next Level modal (overlay shown when player wins) -->
  <div class="modal" id="nextLevelModal" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="backdrop" aria-hidden="true"></div>
    <div class="card">
      <h2 id="nextLevelTitle">Level Complete!</h2>
      <p class="small" id="nextLevelMsg">Great job! Ready for the next challenge?</p>
      <div style="display:flex;gap:8px;justify-content:center;margin-top:12px">
        <button id="advanceBtn">▶ Advance</button>
        <button id="stayBtn" class="secondary">Stay Here</button>
      </div>
    </div>
  </div>

  <!-- Ad modal (simulation) -->
  <div class="modal" id="adModal" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="backdrop" aria-hidden="true"></div>
    <div class="card">
      <h3 id="adTitle">Watching ad…</h3>
      <div class="small" id="adSubtitle">Please wait</div>
      <div class="ad-progress"><i id="adBar"></i></div>
      <div style="display:flex;gap:8px;justify-content:center;margin-top:12px">
        <button id="adCancel" class="secondary">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Game over modal -->
  <div class="modal" id="gameOverModal" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="backdrop" aria-hidden="true"></div>
    <div class="card">
      <h2 id="goTitle">Game Over</h2>
      <div id="goSummary" class="small" style="margin-top:8px;color:var(--muted)"></div>
      <div style="display:flex;gap:8px;justify-content:center;margin-top:12px">
        <button id="playAgain">↻ Play again</button>
        <button id="closeGameOver" class="secondary">Close</button>
      </div>
    </div>
  </div>

  <script>    
function applyTheme(theme) { 
  document.documentElement.setAttribute("data-theme", theme);
  localStorage.setItem("theme", theme); // Save preference
}

// Load saved theme or default to light
const savedTheme = localStorage.getItem("theme") || "light";
applyTheme(savedTheme);
    /* ==========================
       LEVEL CONFIGURATION & STATE
    ==========================*/
    const LEVELS = [
      ["CAT", "DOG", "SUN", "MOON", "STAR", "TREE", "BOOK", "GAME", "PLAY", "HOME"],
      ["RIVER", "MOUNTAIN", "OCEAN", "FOREST", "BRIDGE", "ISLAND", "VALLEY", "DESERT", "CLOUD", "WATER"],
      ["ALGORITHM", "FUNCTION", "VARIABLE", "OBJECT", "WIDGET", "INTERFACE", "NETWORK", "DATABASE", "BINARY", "LOOP"],
      ["JAVASCRIPT", "PERFORMANCE", "OPTIMIZE", "EVENT", "RENDERING", "ASYNCHRONOUS", "OBSERVER", "ENCRYPTION", "COMPILER", "MODULE"],
      ["QUANTUM", "CRYPTOGRAPHY", "PARALLELISM", "MACHINELEARNING", "DEEPLEARNING", "NEUROSCIENCE", "TELEMETRY", "MICROPROCESSOR", "COMPUTERGRAPHICS", "HYPERPARAMETER"]
    ];
    const LEVEL_SIZES = [12, 13, 14, 15, 16];
    const CELL_SIZE_MAP = { 12: '48px', 13: '44px', 14: '42px', 15: '38px', 16: '34px' };

    // highest unlocked level (persisted between sessions)
    let unlockedLevel = parseInt(localStorage.getItem("unlockedLevel") || "1", 10);

    const POWERUP_COSTS = { freeze: 8, shield: 10, restore: 5 };
    const DIRS = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [1, -1], [-1, 1], [-1, -1]];

    function seededFromDate(d = new Date()) {
      const y = d.getFullYear(), m = d.getMonth() + 1, day = d.getDate();
      let str = `${y}-${m}-${day}`; let h = 2166136261 >>> 0;
      for (let i = 0; i < str.length; i++) { h ^= str.charCodeAt(i); h = Math.imul(h, 16777619); }
      return h >>> 0;
    }
    function rng(seed) { let s = seed >>> 0; return () => { s = Math.imul(1664525, s) + 1013904223 >>> 0; return s / 0x100000000; } }


    let state = {
      running: false, paused: false, frozen: false,
      seed: seededFromDate(),
      grid: null, placements: {}, words: [], target: new Set(), found: new Set(), blocked: new Set(),
      score: 0, coins: 10, startTs: 0, elapsedPause: 0,
      pointerDown: false, pointerId: null, startCell: null, currentLine: [],
      shrinkTimerId: null, warnTimeouts: [], graceTimers: {}, shrunkMap: {},
      powerups: { freeze: 0, shield: 0, restore: 0 }, shieldProtected: new Set(), shieldExpiry: null,
      adActive: false, adPausedResume: false,
      level: 1
      
    };

    let mainTimerId = null;
    let autoSaveId = null;


    /* -------------------------
       DOM refs
    -------------------------*/
    const gridEl = document.getElementById('grid');
    const wordListEl = document.getElementById('wordList');
    const timerEl = document.getElementById('timer');
    const scoreEl = document.getElementById('score');
    const coinsEl = document.getElementById('coins');
    const statusEl = document.getElementById('status');

    const startModal = document.getElementById('startModal');
    const startModalBtn = document.getElementById('startModalBtn');
    const closeStart = document.getElementById('closeStart');

    const pauseBtn = document.getElementById('pauseBtn');
    const difficultySelect = document.getElementById('difficulty');
    const levelSelect = document.getElementById('levelSelect');

    const freezeBtn = document.getElementById('freezeBtn');
    const shieldBtn = document.getElementById('shieldBtn');
    const restoreBtn = document.getElementById('restoreBtn');

    const buyFreezeBtn = document.getElementById('buyFreezeBtn');
    const buyShieldBtn = document.getElementById('buyShieldBtn');
    const buyRestoreBtn = document.getElementById('buyRestoreBtn');

    const adFreezeBtn = document.getElementById('adFreezeBtn');
    const adShieldBtn = document.getElementById('adShieldBtn');
    const adRestoreBtn = document.getElementById('adRestoreBtn');

    const adModal = document.getElementById('adModal');
    const adBar = document.getElementById('adBar');
    const adTitle = document.getElementById('adTitle');
    const adSubtitle = document.getElementById('adSubtitle');
    const adCancel = document.getElementById('adCancel');

    const gameOverModal = document.getElementById('gameOverModal');
    const goTitle = document.getElementById('goTitle');
    const goSummary = document.getElementById('goSummary');
    const playAgain = document.getElementById('playAgain');
    const closeGameOver = document.getElementById('closeGameOver');

    const nextLevelModal = document.getElementById('nextLevelModal');
    const nextLevelTitle = document.getElementById('nextLevelTitle');
    const nextLevelMsg = document.getElementById('nextLevelMsg');
    const advanceBtn = document.getElementById('advanceBtn');
    const stayBtn = document.getElementById('stayBtn');

    /* -------------------------
       Rendering helpers
    -------------------------*/


    function renderGrid(grid) {
      gridEl.style.setProperty('--size', grid.length);
      gridEl.innerHTML = '';
      for (let r = 0; r < grid.length; r++) {
        for (let c = 0; c < grid[r].length; c++) {
          const d = document.createElement('div');
          d.className = 'cell';
          d.dataset.r = r;
          d.dataset.c = c;
          d.textContent = grid[r][c] || '';
          d.setAttribute('role', 'button');
          gridEl.appendChild(d);
        }
      }
    }

    function sanitizeId(name) { return name.replace(/\s+/g, '_').replace(/[^\w\-]/g, ''); }

    function renderWords(words) {
      wordListEl.innerHTML = '';
      words.forEach(w => {
        const id = 'w-' + sanitizeId(w);
        const d = document.createElement('div');
        d.className = 'word';
        d.id = id;

        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = w;

        const actions = document.createElement('div');
        actions.className = 'word-actions';

        d.appendChild(label);
        d.appendChild(actions);
        wordListEl.appendChild(d);
      });
    }

    function setStatus(t) { statusEl.textContent = t; }
    function updateScore() { scoreEl.textContent = '🏆 ' + state.score; }
    function updateCoins() { coinsEl.innerHTML = '<img src="../images/goldIcon.png" alt="" class="balanceIcon">' + state.coins; }
    function updatePowerupButtons() {
      freezeBtn.textContent = `Freeze x${state.powerups.freeze}`;
      shieldBtn.textContent = `Shield x${state.powerups.shield}`;
      restoreBtn.textContent = `Restore x${state.powerups.restore}`;
    }

    /* -------------------------
       Save / Load progress
    -------------------------*/
    function saveProgress() {
      try {
        const saveData = {
          seed: state.seed,
          grid: state.grid,
          placements: state.placements,
          words: state.words,
          found: Array.from(state.found),
          blocked: Array.from(state.blocked),
          score: state.score,
          coins: state.coins,
          powerups: state.powerups,
          startTs: state.startTs,
          elapsedPause: state.elapsedPause,
          running: state.running,
          paused: state.paused,
          difficulty: difficultySelect.value,
          level: state.level,
          gridSize: state.grid ? state.grid.length : null,
          unlockedLevel: unlockedLevel
        };
        localStorage.setItem("shrinkingProgress_v4", JSON.stringify(saveData));
        localStorage.setItem("unlockedLevel", String(unlockedLevel));
      } catch (e) {
        console.error("save failed", e);
      }
    }

    function loadProgress() {
      const raw = localStorage.getItem("shrinkingProgress_v4");
      if (!raw) return false;
      try {
        const data = JSON.parse(raw);
        state.seed = data.seed ?? state.seed;
        state.grid = data.grid;
        state.placements = data.placements ?? {};
        state.words = data.words ?? [];
        state.found = new Set(data.found ?? []);
        state.blocked = new Set(data.blocked ?? []);
        state.score = data.score ?? 0;
        state.coins = data.coins ?? 0;
        state.powerups = data.powerups ?? { freeze: 0, shield: 0, restore: 0 };
        state.startTs = data.startTs ?? 0;
        state.elapsedPause = data.elapsedPause ?? 0;
        state.running = !!data.running;
        state.paused = !!data.paused;
        if (data.difficulty) difficultySelect.value = data.difficulty;
        if (data.level) { state.level = data.level; levelSelect.value = String(data.level); }
        if (data.unlockedLevel) unlockedLevel = parseInt(data.unlockedLevel, 10) || unlockedLevel;

        const sizeToApply = data.gridSize || LEVEL_SIZES[(state.level || 1) - 1] || 15;
 

        if (state.grid) renderGrid(state.grid);
        renderWords(state.words);
        updateScore();
        updateCoins();
        updatePowerupButtons();

        state.found.forEach(w => {
          const id = 'w-' + sanitizeId(w);
          const el = document.getElementById(id);
          if (el) el.classList.add('found');
          const coords = state.placements[w];
          if (coords) {
            coords.forEach(({ r, c }) => {
              const cell = gridEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
              if (cell) cell.classList.add('lock');
            });
          }
        });

        state.blocked.forEach(w => {
          const id = 'w-' + sanitizeId(w);
          const el = document.getElementById(id);
          if (el) el.classList.add('blocked');
        });

        for (const key in state.shrunkMap) {
          const [r, c] = key.split(',').map(Number);
          const cell = gridEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
          if (cell) { cell.classList.add('shrunk'); cell.textContent = ''; }
        }

        setStatus("");
        return true;
      } catch (e) {
        console.error("load failed", e);
        return false;
      }
    }

    /* -------------------------
       Timers
    -------------------------*/
    function startMainTimer() {
      clearInterval(mainTimerId); mainTimerId = setInterval(() => {
        if (!state.running || state.paused) return;
        const e = Math.floor((Date.now() - state.startTs - state.elapsedPause) / 1000);
        timerEl.textContent = `||
        ${Math.floor(e / 60)}:${String(e % 60).padStart(2, '0')}`;
      }, 500);
    }

    function clearAllShrinkingTimeouts() { state.warnTimeouts.forEach(t => clearTimeout(t)); state.warnTimeouts = []; for (const k in state.graceTimers) { clearTimeout(state.graceTimers[k]); } state.graceTimers = {}; }

    /* -------------------------
       Level dropdown (hide locked levels)
    -------------------------*/
    function updateLevelDropdown() {
      levelSelect.innerHTML = "";
      for (let i = 1; i <= unlockedLevel; i++) {
        const opt = document.createElement("option");
        opt.value = i;
        let label = `Level ${i}`;
        if (i === 1) label += " — Beginner";
        if (i === 2) label += " — Nature";
        if (i === 3) label += " — Dev Basics";
        if (i === 4) label += " — Advanced Dev";
        if (i === 5) label += " — Expert / Research";
        opt.textContent = label;
        levelSelect.appendChild(opt);
      }
      if (!levelSelect.value || parseInt(levelSelect.value, 10) > unlockedLevel) levelSelect.value = String(unlockedLevel);
    }

    /* -------------------------
       Puzzle builder
    -------------------------*/
    function buildPuzzle({ size = 15, words = [], seed }) {
      const R = rng(seed);
      const grid = Array.from({ length: size }, () => Array(size).fill(null));
      const placements = {};

      function canPlace(w, r, c, dr, dc) {
        const r2 = r + dr * (w.length - 1), c2 = c + dc * (w.length - 1);
        if (r2 < 0 || r2 >= size || c2 < 0 || c2 >= size) return false;
        for (let i = 0; i < w.length; i++) { const rr = r + dr * i, cc = c + dc * i; if (grid[rr][cc] && grid[rr][cc] !== w[i]) return false; }
        return true;
      }

      function placeWord(word) {
        const w = R() < 0.5 ? word.split('').reverse().join('') : word;
        for (let tries = 0; tries < 1200; tries++) {
          const [dr, dc] = DIRS[Math.floor(R() * DIRS.length)];
          const r = Math.floor(R() * size), c = Math.floor(R() * size);
          if (!canPlace(w, r, c, dr, dc)) continue;
          const coords = [];
          for (let i = 0; i < w.length; i++) { grid[r + dr * i][c + dc * i] = w[i]; coords.push({ r: r + dr * i, c: c + dc * i }); }
          return coords;
        }
        return null;
      }

      for (const word of words) {
        placements[word] = placeWord(word);
      }
      for (let r = 0; r < size; r++) for (let c = 0; c < size; c++) if (!grid[r][c]) grid[r][c] = String.fromCharCode(65 + Math.floor(R() * 26));
      return { grid, placements };
    }

    /* -------------------------
       Setup puzzle per level (preview)
    -------------------------*/
    function setupShrinking(level = parseInt(levelSelect.value || '1', 10)) {
      if (level < 1 || level > LEVELS.length) level = 1;
      state.level = level;
      const size = LEVEL_SIZES[level - 1] || 15;


      const words = (LEVELS[level - 1] || []).map(w => String(w).toUpperCase());
      state.words = words.slice();
      state.target = new Set(state.words);
      state.found = new Set(); state.blocked = new Set(); state.shrunkMap = {};
      state.powerups = state.powerups || { freeze: 0, shield: 0, restore: 0 };
      const built = buildPuzzle({ size: size, words: state.words, seed: state.seed });
      state.grid = built.grid; state.placements = built.placements;
      renderGrid(state.grid); renderWords(state.words);
      state.score = 0; updateScore(); updateCoins(); updatePowerupButtons();
      setStatus(`Find all ${state.words.length} words before they break!`);
      saveProgress();
    }

    /* -------------------------
       Selection & pointer handling (mobile-friendly)
    -------------------------*/
    function cellFromPoint(x, y) { const el = document.elementFromPoint(x, y); if (!el) return null; const cell = el.closest('.cell'); if (!cell) return null; if (cell.classList.contains('shrunk')) return null; return { r: +cell.dataset.r, c: +cell.dataset.c, el: cell }; }
    function normalizeDir(dr, dc) { const s = n => n > 0 ? 1 : n < 0 ? -1 : 0; const r = s(dr), c = s(dc); if (r !== 0 && c !== 0 && Math.abs(dr) !== Math.abs(dc)) return null; return [r, c]; }
    function lineCells(from, to) { if (!from || !to) return []; const dr = to.r - from.r, dc = to.c - from.c; const nd = normalizeDir(dr, dc); if (!nd) return []; const [rstep, cstep] = nd; const len = Math.max(Math.abs(dr), Math.abs(dc)); const out = []; for (let i = 0; i <= len; i++) { out.push({ r: from.r + rstep * i, c: from.c + cstep * i }); } return out; }
    function pathToWord(path) { return path.map(p => (state.grid[p.r] && state.grid[p.r][p.c]) || '').join(''); }
    function clearHighlights() { (state.currentLine || []).forEach(p => { const el = gridEl.querySelector(`.cell[data-r="${p.r}"][data-c="${p.c}"]`); if (el && !el.classList.contains('lock') && !el.classList.contains('shrunk')) el.classList.remove('hl', 'good'); }); }
    function highlightPath(path, good = false) { path.forEach(p => { const el = gridEl.querySelector(`.cell[data-r="${p.r}"][data-c="${p.c}"]`); if (el && !el.classList.contains('shrunk')) { if (!el.classList.contains('lock')) el.classList.add(good ? 'good' : 'hl'); p.el = el; } }); }
    function lockPath(path) { path.forEach(p => { const el = gridEl.querySelector(`.cell[data-r="${p.r}"][data-c="${p.c}"]`); if (el) el.classList.add('lock'); }); }

    function beginPointerInteraction(evt) {
      if (!state.running || state.paused) return;
      if (evt.pointerType === 'mouse' && evt.button !== 0) return;
      // preventDefault to stop taps from causing selection/scroll while on grid
      try { evt.preventDefault(); } catch (e) { }
      state.pointerDown = true;
      state.pointerId = evt.pointerId;
      const cell = cellFromPoint(evt.clientX, evt.clientY);
      if (!cell) return;
      state.startCell = { r: cell.r, c: cell.c };
      state.currentLine = [cell];
      clearHighlights();
      highlightPath(state.currentLine);
    }

    function movePointerInteraction(evt) {
      if (!state.pointerDown || !state.running || state.paused) return;
      if (state.pointerId && evt.pointerId !== state.pointerId) return;
      try { evt.preventDefault(); } catch (e) { }
      const cell = cellFromPoint(evt.clientX, evt.clientY);
      if (!cell || !state.startCell) return;
      const path = lineCells(state.startCell, cell);
      clearHighlights();
      if (path.length) {
        state.currentLine = path;
        highlightPath(path);
      }
    }

    function endPointerInteraction(evt) {
      if (!state.pointerDown) return;
      if (state.pointerId && evt.pointerId !== state.pointerId) return;
      try { evt.preventDefault(); } catch (e) { }
      state.pointerDown = false;
      state.pointerId = null;
      const path = state.currentLine || [];
      if (!path.length) {
        clearHighlights();
        state.currentLine = [];
        return;
      }
      const w = pathToWord(path);
      const rev = w.split('').reverse().join('');
      let match = null;
      if (state.target.has(w)) match = w;
      else if (state.target.has(rev)) match = rev;

      if (match && !state.found.has(match)) {
        state.found.add(match); state.score += match.length; updateScore();
        const coinReward = Math.max(1, Math.floor(match.length));
        state.coins += coinReward; updateCoins();
        lockPath(path); highlightPath(path, true);
        const id = 'w-' + sanitizeId(match); const wk = document.getElementById(id); if (wk) wk.classList.add('found');
        setStatus(`Found ${match} — +${match.length} points · +${coinReward} coins`);
        saveProgress();
        if (state.found.size === state.target.size) {
          state.running = false; clearInterval(state.shrinkTimerId); clearAllShrinkingTimeouts();
          showGameOver(true);
        }
      } else {
        setStatus('Only straight lines allowed or already found — try again.');
      }
      clearHighlights(); state.currentLine = [];
    }

    // attach pointer listeners with passive:false so preventDefault works on touch
    gridEl.addEventListener('pointerdown', beginPointerInteraction, { passive: false });
    gridEl.addEventListener('pointermove', movePointerInteraction, { passive: false });
    gridEl.addEventListener('pointerup', endPointerInteraction, { passive: false });
    gridEl.addEventListener('pointercancel', endPointerInteraction, { passive: false });

    /* -------------------------
       Shrinking logic & warnings
    -------------------------*/
    function getDifficultyConfig() { const d = difficultySelect.value; if (d === 'easy') return { shrinkInterval: 15000, warnDuration: 3000, perTick: 1, graceTime: 10000 }; if (d === 'hard') return { shrinkInterval: 4200, warnDuration: 1200, perTick: 5, graceTime: 6000 }; return { shrinkInterval: 6000, warnDuration: 1700, perTick: 3, graceTime: 8000 }; }

    function startShrinking() { const cfg = getDifficultyConfig(); if (state.shrinkTimerId) clearInterval(state.shrinkTimerId); state.shrinkTimerId = setInterval(() => { if (!state.running || state.paused || state.frozen) return; performShrinkTick(cfg); }, cfg.shrinkInterval); }

    function performShrinkTick(cfg) {
      const candidates = [];
      const size = state.grid.length;
      for (let r = 0; r < size; r++) for (let c = 0; c < size; c++) {
        const el = gridEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
        if (!el) continue;
        if (el.classList.contains('lock') || el.classList.contains('shrunk') || el.classList.contains('warn')) continue;
        if (state.shieldProtected.has(`${r},${c}`)) continue;
        candidates.push({ r, c, el });
      }
      if (!candidates.length) return;
      const R = rng(state.seed ^ Date.now());
      const picks = [];
      for (let i = 0; i < cfg.perTick && candidates.length; i++) {
        const idx = Math.floor(R() * candidates.length); picks.push(candidates.splice(idx, 1)[0]);
      }
      picks.forEach(p => p.el.classList.add('warn'));
      const t = setTimeout(() => { finalizeShrunk(picks); }, cfg.warnDuration);
      state.warnTimeouts.push(t);
    }

    function finalizeShrunk(picks) {
      picks.forEach(p => {
        p.el.classList.remove('warn'); const r = p.r, c = p.c; const key = `${r},${c}`;
        const letter = state.grid[r][c]; state.shrunkMap[key] = letter;
        state.grid[r][c] = null; p.el.textContent = '';
        p.el.classList.add('shrunk');
      });
      checkWordsAfterShrink();
      saveProgress();
    }

    function checkWordsAfterShrink() {
      for (const word of state.words) {
        if (state.found.has(word) || state.blocked.has(word)) continue;
        const coords = state.placements[word]; if (!coords) continue;
        const affected = coords.some(({ r, c }) => state.grid[r][c] === null);
        if (affected) { startGraceForWord(word); }
      }
    }

    function startGraceForWord(word) {
      if (state.graceTimers[word]) return;
      const cfg = getDifficultyConfig(); const grace = cfg.graceTime;
      const id = 'w-' + sanitizeId(word); const el = document.getElementById(id); if (el) el.classList.add('blocked');
      setStatus(`Word ${word} damaged, restore letters within ${Math.floor(grace / 1000)}s or you lose.`);
      addWordRestoreActions(word);
      state.graceTimers[word] = setTimeout(() => { finalizeBlock(word); }, grace);
      saveProgress();
    }

    function finalizeBlock(word) {
      state.blocked.add(word);
      removeWordRestoreActions(word);
      setStatus(`Word ${word} was lost — game over.`);
      state.running = false; clearInterval(state.shrinkTimerId); clearAllShrinkingTimeouts(); showGameOver(false, `A required word (${word}) was destroyed.`);
      saveProgress();
    }

    /* -------------------------
       Restore & word actions
    -------------------------*/
    function restoreOneLetterForWord(word) {
      if (!state.placements || !state.placements[word]) return false;
      const coords = state.placements[word];
      let foundKey = null;
      for (const { r, c } of coords) {
        const key = `${r},${c}`;
        if (state.shrunkMap[key]) { foundKey = key; break; }
      }
      if (!foundKey) return false;
      const [sr, sc] = foundKey.split(',').map(n => +n);
      state.grid[sr][sc] = state.shrunkMap[foundKey]; delete state.shrunkMap[foundKey];
      const el = gridEl.querySelector(`.cell[data-r="${sr}"][data-c="${sc}"]`);
      if (el) { el.textContent = state.grid[sr][sc]; el.classList.remove('shrunk'); el.classList.remove('warn'); }
      setStatus(`Restored 1 letter for ${word}`);
      const stillAffected = coords.some(({ r, c }) => state.grid[r][c] === null);
      if (!stillAffected) {
        clearTimeout(state.graceTimers[word]); delete state.graceTimers[word];
        const id = 'w-' + sanitizeId(word); const elw = document.getElementById(id); if (elw) elw.classList.remove('blocked');
        removeWordRestoreActions(word);
        setStatus(`${word} fully restored!`);
      }
      saveProgress();
      return true;
    }

    function addWordRestoreActions(word) {
      const id = 'w-' + sanitizeId(word);
      const el = document.getElementById(id); if (!el) return;
      const container = el.querySelector('.word-actions');
      container.innerHTML = '';

      const buyBtn = document.createElement('button');
      buyBtn.className = 'small-btn tiny';
      buyBtn.textContent = `Restore 1 (${POWERUP_COSTS.restore}c)`;
      buyBtn.addEventListener('click', () => {
        if (state.coins < POWERUP_COSTS.restore) { setStatus('Not enough coins to buy a letter restore.'); return; }
        state.coins -= POWERUP_COSTS.restore; updateCoins(); saveProgress();
        const ok = restoreOneLetterForWord(word);
        if (!ok) setStatus('No letters to restore.');
      });

      const adBtn = document.createElement('button');
      adBtn.className = 'small-btn tiny';
      adBtn.textContent = 'Watch Ad → Restore 1';
      adBtn.addEventListener('click', () => {
        openAd('restore-letter', { word });
      });

      container.appendChild(buyBtn);
      container.appendChild(adBtn);
    }

    function removeWordRestoreActions(word) {
      const id = 'w-' + sanitizeId(word);
      const el = document.getElementById(id); if (!el) return;
      const container = el.querySelector('.word-actions');
      if (container) container.innerHTML = '';
    }

    /* -------------------------
       Power-ups & ads
    -------------------------*/
    function buyPowerup(type) {
      const cost = POWERUP_COSTS[type];
      if (state.coins < cost) { setStatus('Not enough coins'); return false; }
      state.coins -= cost; state.powerups[type] = (state.powerups[type] || 0) + 1; updateCoins(); updatePowerupButtons();
      setStatus(`Purchased 1 ${type} for ${cost} coins`);
      saveProgress();
      return true;
    }

    function openAd(kind, payload) {
      if (state.adActive) return;
      state.adActive = true;
      state.adPausedResume = (state.running && !state.paused);
      if (state.adPausedResume) doPause();
      adTitle.textContent = 'Watching ad…';
      adSubtitle.textContent = 'Thank you for supporting the game';
      adBar.style.width = '0%';
      openModal(adModal);
      let p = 0; const duration = 4500 + Math.floor(Math.random() * 2000);
      const start = Date.now();
      const interval = setInterval(() => {
        const elapsed = Date.now() - start;
        p = Math.min(1, elapsed / duration);
        adBar.style.width = `${Math.floor(p * 100)}%`;
        if (p >= 1) {
          clearInterval(interval);
          closeModal(adModal);
          finalizeAd(kind, payload);
          state.adActive = false;
          if (state.adPausedResume) { doResume(); state.adPausedResume = false; }
          saveProgress();
        }
      }, 80);

      adCancel.onclick = () => {
        clearInterval(interval);
        closeModal(adModal);
        state.adActive = false;
        if (state.adPausedResume) { doResume(); state.adPausedResume = false; }
        setStatus('Ad cancelled');
      };
    }

    function finalizeAd(kind, payload) {
      if (kind === 'restore-letter') {
        const ok = restoreOneLetterForWord(payload.word);
        if (!ok) setStatus('Ad reward: nothing to restore');
        else setStatus('Ad reward: restored 1 letter');
      } else if (kind === 'restore-pu') {
        state.powerups.restore = (state.powerups.restore || 0) + 1; updatePowerupButtons(); setStatus('Ad reward: +1 Restore power-up');
      } else if (kind === 'freeze-pu') {
        state.powerups.freeze = (state.powerups.freeze || 0) + 1; updatePowerupButtons(); setStatus('Ad reward: +1 Freeze power-up');
      } else if (kind === 'shield-pu') {
        state.powerups.shield = (state.powerups.shield || 0) + 1; updatePowerupButtons(); setStatus('Ad reward: +1 Shield power-up');
      } else if (kind === 'coins') {
        const amt = 5 + Math.floor(Math.random() * 6);
        state.coins += amt; updateCoins(); setStatus(`Ad reward: +${amt} coins`);
      } else {
        state.coins += 3; updateCoins(); setStatus('Ad reward: +3 coins');
      }
      saveProgress();
    }

    function useFreeze() { if (!state.running || state.paused) return; if (state.powerups.freeze <= 0) { setStatus('No Freeze power-ups — buy or watch an ad.'); return; } state.powerups.freeze--; updatePowerupButtons(); state.frozen = true; setStatus('Shrinking frozen for 8s'); saveProgress(); setTimeout(() => { state.frozen = false; setStatus('Shrinking resumed'); }, 8000); }

    function useShield() {
      if (!state.running || state.paused) return; if (state.powerups.shield <= 0) { setStatus('No Shield power-ups — buy or watch an ad.'); return; } state.powerups.shield--; updatePowerupButtons();
      const protectedCount = 8; const size = state.grid.length; const R = rng(state.seed ^ Date.now()); const candidates = [];
      for (let r = 0; r < size; r++) for (let c = 0; c < size; c++) { const key = `${r},${c}`; const el = gridEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`); if (!el) continue; if (el.classList.contains('lock') || el.classList.contains('shrunk') || state.shieldProtected.has(key)) continue; candidates.push({ r, c, el }); }
      for (let i = 0; i < protectedCount && candidates.length; i++) { const idx = Math.floor(R() * candidates.length); const p = candidates.splice(idx, 1)[0]; state.shieldProtected.add(`${p.r},${p.c}`); p.el.classList.add('warn'); p.el.dataset._shield = '1'; }
      setStatus('Shield active for 10s — protected cells highlighted.');
      saveProgress();
      if (state.shieldExpiry) clearTimeout(state.shieldExpiry);
      state.shieldExpiry = setTimeout(() => { state.shieldProtected.forEach(k => { const [r, c] = k.split(','); const el = gridEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`); if (el && el.dataset._shield) { delete el.dataset._shield; el.classList.remove('warn'); } }); state.shieldProtected.clear(); setStatus('Shield expired.'); saveProgress(); }, 10000);
    }

    function useRestore() {
      if (!state.running) return; if (state.powerups.restore <= 0) { setStatus('No Restore power-ups left — buy or watch an ad to restore letters one at a time.'); return; }
      const shrunkKeys = Object.keys(state.shrunkMap); if (!shrunkKeys.length) { setStatus('No removed letters to restore.'); return; }
      let pickKey = null;
      for (const word of state.words) { if (state.found.has(word)) continue; if (!state.placements[word]) continue; const coords = state.placements[word]; for (const { r, c } of coords) { const key = `${r},${c}`; if (state.shrunkMap[key]) { pickKey = key; break; } } if (pickKey) break; }
      if (!pickKey) pickKey = shrunkKeys[0];
      const [sr, sc] = pickKey.split(',').map(n => +n); state.grid[sr][sc] = state.shrunkMap[pickKey]; delete state.shrunkMap[pickKey]; const el = gridEl.querySelector(`.cell[data-r="${sr}"][data-c="${sc}"]`); if (el) { el.textContent = state.grid[sr][sc]; el.classList.remove('shrunk'); }
      state.powerups.restore--; updatePowerupButtons(); saveProgress();
      for (const word of Object.keys(state.graceTimers)) {
        if (!state.placements[word]) continue; const coords = state.placements[word]; const stillAffected = coords.some(({ r, c }) => state.grid[r][c] === null);
        if (!stillAffected) { clearTimeout(state.graceTimers[word]); delete state.graceTimers[word]; const id = 'w-' + sanitizeId(word); const elW = document.getElementById(id); if (elW) elW.classList.remove('blocked'); removeWordRestoreActions(word); setStatus(`Restored letters — ${word} saved!`); saveProgress(); }
      }
    }

    /* -------------------------
       Pause / Resume
    -------------------------*/
    function doPause() { if (!state.running || state.paused) return; state.paused = true; state.pauseStart = Date.now(); setStatus('Paused'); if (state.shrinkTimerId) clearInterval(state.shrinkTimerId); saveProgress(); }
    function doResume() { if (!state.running || !state.paused) return; state.paused = false; state.elapsedPause += Date.now() - state.pauseStart; setStatus(`Find all ${state.words.length} words before they break!`); if (state.running) startShrinking(); saveProgress(); }

    /* -------------------------
       Start / Reset / GameOver + next-level overlay
    -------------------------*/
    function startGame() {
      // if no grid or not prepared, generate preview then start
      if (!state.grid || !state.words || state.words.length === 0) {
        setupShrinking(parseInt(levelSelect.value || '1', 10));
      }
      state.running = true;
      state.paused = false;
      setupShrinking(parseInt(levelSelect.value || '1', 10));
      state.elapsedPause = 0;
      state.startTs = Date.now();
      startMainTimer();
      startShrinking();
      setStatus('Game started, stay sharp!');
      closeModal(startModal);
      saveProgress();
    }

    function resetForPlayAgain() {
      state.seed = seededFromDate();
      setupShrinking(parseInt(levelSelect.value || '1', 10));
      state.running = true; state.paused = false; state.startTs = Date.now(); state.elapsedPause = 0;
      startMainTimer(); startShrinking(); closeModal(gameOverModal);
      saveProgress();
    }

    function showGameOver(won = false, msg = '') {
      goTitle.textContent = won ? 'You did it!' : 'Game Over';
      goSummary.textContent = msg || `Score: ${state.score} · Found ${state.found.size}/${state.target.size} words`;
      if (!won) {
        openModal(gameOverModal);
      } else {
        // Unlock next level if necessary
        if (state.level < LEVELS.length && state.level >= unlockedLevel) {
          unlockedLevel = state.level + 1;
          localStorage.setItem("unlockedLevel", unlockedLevel);
          updateLevelDropdown();
        }
        nextLevelTitle.textContent = `Level ${state.level} Complete!`;
        if (state.level < LEVELS.length) {
          nextLevelMsg.textContent = `You unlocked Level ${state.level + 1}. Press Advance to preview Level ${state.level + 1}, then press Start to begin.`;
        } else {
          nextLevelMsg.textContent = `Amazing — you finished all ${LEVELS.length} levels! Press Advance to preview or replay the final level.`;
        }
        openModal(nextLevelModal);
      }
      saveProgress();
    }

    // Advance button: preview next level and open Start modal (player must press Start)
    advanceBtn.addEventListener('click', () => {
      closeModal(nextLevelModal);
      let targetLevel = state.level;
      if (state.level < LEVELS.length) targetLevel = state.level + 1;
      if (targetLevel > unlockedLevel) targetLevel = unlockedLevel;
      levelSelect.value = String(targetLevel);
      setupShrinking(targetLevel);
      openModal(startModal);
    });
    stayBtn.addEventListener('click', () => { closeModal(nextLevelModal); setStatus('You can replay or advance later from the Level menu.'); });

    /* -------------------------
       Wiring events
    -------------------------*/
    startModalBtn.addEventListener('click', () => startGame());
    closeStart.addEventListener('click', () => closeModal(startModal));
    pauseBtn.addEventListener('click', () => { if (state.running) { if (state.paused) doResume(); else doPause(); } });
    difficultySelect.addEventListener('change', () => { if (state.running) { startShrinking(); saveProgress(); } });

    levelSelect.addEventListener('change', () => {
      const lvl = parseInt(levelSelect.value || '1', 10);
      if (state.running) {
        setStatus(`Level changed to ${lvl} — resetting game.`);
        levelSelect.value = String(lvl);
        resetForPlayAgain();
      } else {
        setupShrinking(lvl);
        setStatus(`Previewing level ${lvl}. Press Start to begin.`);
      }
    });

    freezeBtn.addEventListener('click', useFreeze);
    shieldBtn.addEventListener('click', useShield);
    restoreBtn.addEventListener('click', useRestore);

    buyFreezeBtn.addEventListener('click', () => buyPowerup('freeze'));
    buyShieldBtn.addEventListener('click', () => buyPowerup('shield'));
    buyRestoreBtn.addEventListener('click', () => buyPowerup('restore'));

    adFreezeBtn.addEventListener('click', () => openAd('freeze-pu'));
    adShieldBtn.addEventListener('click', () => openAd('shield-pu'));
    adRestoreBtn.addEventListener('click', () => openAd('restore-pu'));

    playAgain.addEventListener('click', () => resetForPlayAgain());
    closeGameOver.addEventListener('click', () => closeModal(gameOverModal));

    window.addEventListener('keydown', (e) => { if (e.code === 'Space') { e.preventDefault(); if (state.running) { if (state.paused) doResume(); else doPause(); } } if (e.key === 'Escape') { if (gameOverModal.classList.contains('open')) closeModal(gameOverModal); else if (startModal.classList.contains('open')) closeModal(startModal); } });

    /* -------------------------
       Auto-save
    -------------------------*/
    function startAutoSave() {
      if (autoSaveId) clearInterval(autoSaveId);
      autoSaveId = setInterval(() => { saveProgress(); }, 5000);
    }

    /* -------------------------
       Modal helpers
    -------------------------*/
    function openModal(modal) { modal.classList.add('open'); document.body.classList.add('modal-open'); modal.setAttribute('aria-hidden', 'false'); }
    function closeModal(modal) { modal.classList.remove('open'); modal.setAttribute('aria-hidden', 'true'); if (!document.querySelector('.modal.open')) document.body.classList.remove('modal-open'); }

    /* -------------------------
       Bootstrap
    -------------------------*/
    (function bootstrap() {
      updateLevelDropdown();
      const restored = loadProgress();
      updateLevelDropdown();
      if (restored) {
        updateScore(); updateCoins(); updatePowerupButtons(); updateLevelDropdown();
        if (state.running && !state.paused) {
          startMainTimer();
          startShrinking();
        }
        setStatus('Progress restored from previous session.');
      } else {
        levelSelect.value = String(unlockedLevel || 1);
        setupShrinking(unlockedLevel || 1);
        setStatus('Preview: choose a level and press Start to begin shrinking mode.');
      }
      startAutoSave();
    })();

  </script>
</body>

</html>